<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>BLACKOUT MAZE - Infinite SEGA Horror</title>
<style>
  body { margin:0; background:#000; overflow:hidden; font-family:'Courier New',monospace; color:#0f0; }
  #game { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); image-rendering:pixelated; box-shadow:0 0 40px #000; }
  #hud { position:absolute; top:8px; left:8px; font-size:14px; text-shadow:0 0 4px #000; pointer-events:none; color:#00ff88; }
  #msg { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; font-size:32px; color:#f00; background:rgba(0,0,0,0.8); opacity:0; transition:opacity 0.5s; pointer-events:none; font-weight:bold; text-shadow:0 0 8px #f00; }
  #minimap { position:absolute; top:8px; right:8px; width:96px; height:70px; background:rgba(0,0,0,0.7); border:2px solid #0f0; display:none; image-rendering:pixelated; pointer-events:none; }
</style>
</head>
<body>

<canvas id="game" width="320" height="224"></canvas>
<div id="hud">BREAKERS: <span id="count">0</span>/5  |  FLOOR: <span id="floor">1</span></div>
<canvas id="minimap" width="96" height="70"></canvas>
<div id="msg"></div>

<script>
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SEGA GENESIS INFINITE MAZE HORROR
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const minimapCtx = document.getElementById('minimap').getContext('2d');
canvas.style.width = '960px';
canvas.style.height = '672px';

const TILE = 16;
const MAP_W = 22;
const MAP_H = 15;

const PAL = {
  bg: '#0a0a1a',
  floor: '#1a1a2a',
  wall1: '#444444',
  wall2: '#666666',
  wall3: '#888888',
  locker: '#555555',
  breakerOff: '#ff6600',
  breakerOn: '#00ff88',
  playerBody: '#40e0d0',
  playerHead: '#60f0e0',
  playerEye: '#00ffff',
  playerShirt: '#20b0a0',
  monsterBody: '#660000',
  monsterHead: '#880000',
  monsterEye: '#ff2222',
  monsterMouth: '#ff0000',
  lightGlow: '#ffff88',
  ui: '#00ff88',
  winGlow: '#ffff00'
};

let cameraX = 0, cameraY = 0;
let player = { x: 1.5, y: 1.5, vx: 0, vy: 0, facingX: 1, facingY: 0 };
let monster = { x: 20.5, y: 13.5, vx: 0, vy: 0 };
let breakers = [];
let activated = 0;
let gameOver = false;
let won = false;
let flashlight = false;
let showMap = false;
let floorNum = 1;
let map = [];
let moveAnim = 0;

// Maze generation (recursive backtracker)
function generateMaze() {
  // Initialize walls
  map = Array(MAP_H).fill().map(() => Array(MAP_W).fill('#'));
  
  // Start carving from (1,1)
  const stack = [];
  const startX = 1, startY = 1;
  map[startY][startX] = '.';
  stack.push([startX, startY]);

  while (stack.length) {
    const [cx, cy] = stack[stack.length - 1];
    const dirs = [[0, -2], [2, 0], [0, 2], [-2, 0]].filter(([dx, dy]) => {
      const nx = cx + dx, ny = cy + dy;
      return nx > 0 && nx < MAP_W - 1 && ny > 0 && ny < MAP_H - 1 && map[ny][nx] === '#';
    });
    
    if (dirs.length) {
      const [dx, dy] = dirs[Math.floor(Math.random() * dirs.length)];
      const wx = cx + dx / 2, wy = cy + dy / 2;
      map[cy + dy][cx + dx] = '.';
      map[wy][wx] = '.';
      stack.push([cx + dx, cy + dy]);
    } else {
      stack.pop();
    }
  }

  // Place 5 breakers randomly in open spaces
  breakers = [];
  let attempts = 0;
  while (breakers.length < 5 && attempts < 100) {
    const x = 1 + Math.floor(Math.random() * (MAP_W - 2));
    const y = 1 + Math.floor(Math.random() * (MAP_H - 2));
    if (map[y][x] === '.') {
      map[y][x] = 'B';
      breakers.push({x: x + 0.5, y: y + 0.5, active: false});
    }
    attempts++;
  }

  // Reset positions
  player.x = 1.5; player.y = 1.5; player.vx = 0; player.vy = 0;
  monster.x = MAP_W - 1.5; monster.y = MAP_H - 1.5;
  activated = 0;
  document.getElementById('count').textContent = 0;
  document.getElementById('floor').textContent = ++floorNum;
  won = false;
  gameOver = false;
}

const keys = {};
window.addEventListener('keydown', e => {
  keys[e.key.toLowerCase()] = true;
  if (e.key === ' ') flashlight = !flashlight;
  if (e.key.toLowerCase() === 'shift') {
    showMap = !showMap;
    document.getElementById('minimap').style.display = showMap ? 'block' : 'none';
  }
  if (e.key.toLowerCase() === 'e') activateBreaker();
});
window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

function isWalkable(x, y) {
  const tx = Math.floor(x), ty = Math.floor(y);
  return tx >= 0 && tx < MAP_W && ty >= 0 && ty < MAP_H && map[ty][tx] !== '#';
}

function activateBreaker() {
  for (let b of breakers) {
    if (!b.active) {
      const dx = Math.abs(b.x - player.x);
      const dy = Math.abs(b.y - player.y);
      if (dx < 1.2 && dy < 1.2) {
        b.active = true;
        activated++;
        document.getElementById('count').textContent = activated;
        showMsg('BREAKER POPPED!', PAL.ui);
        if (activated >= 5) {
          setTimeout(() => {
            showMsg('FLOOR CLEARED!\nGENERATING NEXT...', PAL.winGlow, 2000);
            setTimeout(generateMaze, 2000);
          }, 1000);
        }
        return;
      }
    }
  }
}

function update() {
  if (gameOver || won) return;

  // Slower player movement (0.08 per frame ~ smooth walk)
  const speed = 0.08;
  player.vx = 0; player.vy = 0;
  if (keys['w'] || keys['arrowup']) { player.vy = -speed; player.facingY = -1; }
  if (keys['s'] || keys['arrowdown']) { player.vy = speed; player.facingY = 1; }
  if (keys['a'] || keys['arrowleft']) { player.vx = -speed; player.facingX = -1; }
  if (keys['d'] || keys['arrowright']) { player.vx = speed; player.facingX = 1; }

  // Move & collide
  let nx = player.x + player.vx, ny = player.y + player.vy;
  if (isWalkable(nx, player.y)) player.x = nx;
  if (isWalkable(player.x, ny)) player.y = ny;

  // Camera follow
  cameraX = player.x * TILE - 160;
  cameraY = player.y * TILE - 112;

  // Monster AI (pathfinding lite)
  const mDist = dist(player.x, player.y, monster.x, monster.y);
  if (mDist < 8 || flashlight && mDist < 12) {
    const dx = (player.x > monster.x ? 0.04 : -0.04);
    const dy = (player.y > monster.y ? 0.04 : -0.04);
    let nx = monster.x + dx, ny = monster.y + dy;
    if (isWalkable(nx, monster.y)) monster.x = nx;
    if (isWalkable(monster.x, ny)) monster.y = ny;
  } else {
    // Random patrol
    if (Math.random() < 0.02) {
      const dirs = [[0.2,0],[-0.2,0],[0,0.2],[0,-0.2]];
      const [dx, dy] = dirs[Math.floor(Math.random()*4)];
      let nx = monster.x + dx, ny = monster.y + dy;
      if (isWalkable(nx, monster.y)) monster.x = nx;
      if (isWalkable(monster.x, ny)) monster.y = ny;
    }
  }

  // Caught
  if (dist(player.x, player.y, monster.x, monster.y) < 0.8) jumpscare();

  moveAnim += Math.abs(player.vx) + Math.abs(player.vy);
}

function dist(x1,y1,x2,y2) { return Math.hypot(x1-x2, y1-y2); }

function jumpscare() {
  gameOver = true;
  showMsg('JUMPSCARE!\nCAUGHT!', '#ff0000', 9999);
  try {
    const a = new AudioContext();
    const o = a.createOscillator(); o.type = 'sawtooth';
    o.frequency.setValueAtTime(180, a.currentTime);
    o.frequency.exponentialRampToValueAtTime(60, a.currentTime + 0.7);
    o.connect(a.destination); o.start(); o.stop(a.currentTime + 0.7);
  } catch(e) {}
}

function showMsg(text, color = PAL.ui, duration = 1500) {
  const el = document.getElementById('msg');
  el.innerHTML = text.replace('\n', '<br>');
  el.style.color = color;
  el.style.opacity = 1;
  setTimeout(() => el.style.opacity = 0, duration);
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// DETAILED PIXEL SPRITES & RENDER
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function render() {
  ctx.fillStyle = PAL.bg;
  ctx.fillRect(0, 0, 320, 224);

  // Tiles
  for (let y = 0; y < MAP_H; y++) {
    for (let x = 0; x < MAP_W; x++) {
      const tile = map[y][x];
      const sx = x * TILE - cameraX;
      const sy = y * TILE - cameraY;
      if (sx > -TILE && sx < 340 && sy > -TILE && sy < 244) {
        if (tile === '#') {
          // Gray walls with detail
          ctx.fillStyle = PAL.wall1;
          ctx.fillRect(sx, sy, TILE, TILE);
          ctx.fillStyle = PAL.wall3;
          ctx.fillRect(sx + 2, sy + 2, TILE - 4, 6);
          ctx.fillRect(sx + 2, sy + TILE - 8, TILE - 4, 6);
          ctx.fillStyle = PAL.locker;
          ctx.fillRect(sx + TILE/2 - 2, sy + 4, 4, 8);
        } else if (tile !== 'B') {
          // Floor with color variation
          ctx.fillStyle = PAL.floor;
          ctx.fillRect(sx, sy, TILE, TILE);
          ctx.fillStyle = '#2a2a40';
          ctx.fillRect(sx + 4, sy + 4, 8, 8);
        }
      }
    }
  }

  // Breakers (glowing box)
  breakers.forEach(b => {
    const sx = b.x * TILE - cameraX;
    const sy = b.y * TILE - cameraY;
    if (sx > -TILE && sx < 340 && sy > -TILE && sy < 244) {
      ctx.fillStyle = b.active ? PAL.breakerOn : PAL.breakerOff;
      ctx.shadowColor = b.active ? '#00ff88' : '#ff8800';
      ctx.shadowBlur = 8;
      ctx.fillRect(sx - 4, sy - 4, TILE + 8, TILE + 8);
      ctx.shadowBlur = 0;
      ctx.fillStyle = '#331100';
      ctx.fillRect(sx - 1, sy - 1, TILE + 2, TILE + 2);
      // Lock detail
      ctx.fillStyle = '#ffaa44';
      ctx.fillRect(sx + 2, sy + 2, 6, 6);
    }
  });

  // Player sprite (detailed kid)
  const px = player.x * TILE - cameraX;
  const py = player.y * TILE - cameraY;
  const animFrame = Math.floor(moveAnim * 0.3) % 2;
  ctx.save();
  ctx.translate(px, py);
  ctx.scale(player.facingX, player.facingY);
  // Legs
  ctx.fillStyle = '#204040';
  ctx.fillRect(-3 + animFrame * 2, 8, 3, 6);
  ctx.fillRect(0 - animFrame * 2, 8, 3, 6);
  // Body
  ctx.fillStyle = PAL.playerShirt;
  ctx.fillRect(-5, 0, 10, 12);
  // Arms
  ctx.fillStyle = PAL.playerBody;
  ctx.fillRect(-7, 2, 4, 6);
  ctx.fillRect(3, 2, 4, 6);
  // Head
  ctx.fillStyle = PAL.playerHead;
  ctx.fillRect(-4, -12, 8, 10);
  ctx.fillStyle = '#101010';
  ctx.fillRect(-2, -9, 4, 3);
  // Eyes
  ctx.fillStyle = PAL.playerEye;
  ctx.fillRect(-1.5, -7, 1.5, 1.5);
  ctx.fillRect(0.5, -7, 1.5, 1.5);
  ctx.restore();

  // Monster sprite (detailed shadow beast)
  const mx = monster.x * TILE - cameraX;
  const my = monster.y * TILE - cameraY;
  if (flashlight || dist(player.x, player.y, monster.x, monster.y) < 6) {
    ctx.save();
    ctx.translate(mx, my);
    // Body
    ctx.fillStyle = PAL.monsterBody;
    ctx.fillRect(-8, -4, 16, 20);
    ctx.fillStyle = PAL.monsterHead;
    ctx.fillRect(-10, -16, 20, 14);
    // Eyes glow
    ctx.shadowColor = '#ff6666';
    ctx.shadowBlur = 12;
    ctx.fillStyle = PAL.monsterEye;
    ctx.fillRect(-6, -12, 5, 6);
    ctx.fillRect(1, -12, 5, 6);
    ctx.shadowBlur = 0;
    // Teeth
    ctx.fillStyle = PAL.monsterMouth;
    ctx.fillRect(-4, -4, 8, 4);
    ctx.fillStyle = '#ffffff';
    for (let i = -3; i <= 3; i += 2) ctx.fillRect(-4 + i * 2, -4, 1.5, 2);
    ctx.restore();
  }

  // Flashlight radial light
  if (flashlight) {
    const grad = ctx.createRadialGradient(px, py, 0, px + player.facingX * 20, py + player.facingY * 20, 140);
    grad.addColorStop(0, 'rgba(255,255,150,0.5)');
    grad.addColorStop(0.3, 'rgba(150,200,255,0.3)');
    grad.addColorStop(0.7, 'rgba(50,100,150,0.1)');
    grad.addColorStop(1, 'rgba(0,0,0,1)');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, 320, 224);
  } else {
    ctx.fillStyle = 'rgba(5,5,15,0.97)';
    ctx.fillRect(0, 0, 320, 224);
  }

  // Scanlines + vignette
  ctx.fillStyle = 'rgba(0,0,0,0.2)';
  for (let y = 0; y < 224; y += 2) ctx.fillRect(0, y, 320, 1);
  const vig = ctx.createRadialGradient(160,112,0,160,112,200);
  vig.addColorStop(0,'rgba(0,0,0,0)'); vig.addColorStop(1,'rgba(0,0,0,0.5)');
  ctx.fillStyle = vig; ctx.fillRect(0,0,320,224);

  renderMinimap();
}

function renderMinimap() {
  minimapCtx.fillStyle = '#000';
  minimapCtx.fillRect(0, 0, 96, 70);
  const scale = 4;
  for (let y = 0; y < MAP_H; y++) {
    for (let x = 0; x < MAP_W; x++) {
      minimapCtx.fillStyle = map[y][x] === '#' ? PAL.wall2 : '#222';
      minimapCtx.fillRect(x * scale, y * scale, scale, scale);
    }
  }
  // Player green
  minimapCtx.fillStyle = '#0f0';
  minimapCtx.fillRect(player.x * scale - 1, player.y * scale - 1, 3, 3);
  // Monster red
  minimapCtx.fillStyle = '#f00';
  minimapCtx.fillRect(monster.x * scale - 1.5, monster.y * scale - 1.5, 4, 4);
  // Breakers
  breakers.forEach(b => {
    minimapCtx.fillStyle = b.active ? '#0f0' : '#ff0';
    minimapCtx.fillRect((b.x-0.5) * scale + 0.5, (b.y-0.5) * scale + 0.5, 2, 2);
  });
}

function loop() {
  update();
  render();
  requestAnimationFrame(loop);
}

// Init first maze
generateMaze();
showMsg('NEW MAZE!\nFind 5 breakers (E)\nSPACE=Light  SHIFT=Map\nAvoid the beast!', PAL.ui, 5000);
loop();
</script>

<h3 style="text-align:center; color:#0f0; margin:20px; font-family:Courier New;">
  WASD/Arrows: Move (slower now) | E: Pop Breaker | SPACE: Flashlight | SHIFT: Minimap<br>
  Infinite floors, Elias! Each clear = new maze. More colors, better sprites, gray walls! ğŸ«ğŸ”¥
</h3>

</body>
</html>
